# clib

                                                                 
        _____   _____              ____________ ______  ______   
   _____\    \_|\    \            /            \\     \|\     \  
  /     /|     |\\    \          |\___/\  \\___/||     |\|     | 
 /     / /____/| \\    \          \|____\  \___|/|     |/____ /  
|     | |____|/   \|    | ______        |  |     |     |\     \  
|     |  _____     |    |/      \  __  /   / __  |     | |     | 
|\     \|\    \    /            | /  \/   /_/  | |     | |     | 
| \_____\|    |   /_____/\_____/||____________/|/_____/|/_____/| 
| |     /____/|  |      | |    |||           | /|    |||     | | 
 \|_____|    ||  |______|/|____|/|___________|/ |____|/|_____|/  
        |____|/                                                  

维护一个c语言的项目的起点就是看懂它是如何构建的，对于文件有点多的项目看懂构建文件就是个大工程，对于没有相关规模的c语言新手来说，这几乎就是一种徒劳，所以进步最快的一种方式就是自己写一个类似的项目，写完之后再回头看出名的开源项目就会容易些。

这个项目采用了两种构建工具ninja和CMake，前者用于代码无bug时的构建，后者用于调试bug时使用。

ninja构建: 编译: `ninja`，测试: `test.exe`，清除: `ninja -t clean`

CMake构建: VSCode编写完CMakeLists.txt后按`Ctrl + s`就会自动生成build目录，再用VS打开build目录中的.sln文件即可构建，更多VS的使用请参考搜索引擎。

## 注意

该代码可能不能编译，每天都会做修改优化，使其以达到一个理想的状态，目前很多设计都不合理，所以进度不能过快，等哪天觉得设计比较合理了，再快速推进项目的进度也不迟，这样到最后返工修改的几率也会小一些，最糟糕的情况是编写了大量的篇幅却发现了新的更好的设计，到那时候再修改工作量就很大了。

## 其它

有实力的可以直接去维护和修改glib来达到自己开发需求，但对于我这样的c语言新手，从头开发一个才是最快速的进步方式。然后这是个完全没有任何企图赚钱的项目，因为之前的母项目几乎要黄了，遇到了非常大的困难，以至于我几个月毫无进展，我不知道这种状态会持续多久，所以这个项目的进度恐怕会很缓慢，完全看心情。

## 符号

[*] ~ 修改功能，[*] + 增加功能，[*] - 删减功能，[*] ^ 编写文档，[/d./d./d] * 新版本发布

其中/d为数字[0-9]，第一个/d为版本，第二个/d为功能数，第三个/d为原来功能数所迭代的次数。原则是当功能数超过10个的时候，版本号就要加1，除第一个/d可以大于9，后面的/d都不能大于9。

## 原则

效率 > 规定，也就是解决问题的方式上，当效率的收益大于规则所的收益时，就选则使用效率的方式解决问题，反之逆然。

## 测试

[✔] ArrayList

## CODING

[ ] LinkedList
[ ] HashMap

## 鸣谢

* VSCode
* Visual Studio
* VIM